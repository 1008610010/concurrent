
###大纲
* volatitle的特点：内存可见性、禁止重排序
* 内存可见性
  + 什么是内存可见性
  + JMM(Java内存模型)之happens-before规则
* 重排序
  + JMM(java内存模型)之as-if-serial语义
* volatile 实现原理
* volatile 性能
* volatile 适用的场景

### 内存可见性
 * 什么是内存可见性？
&ensp; &ensp; 通常情况下，我们无法确保读线程能够适时地看到其他线程写入的最新的值。这是由于JMM规定了所有的变量都存储在主内存中(虚拟机内存的一部分)。每条线程还有自己的工作内存,线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。**不同的线程之间也无法直接访问对方工作内存中的变量**，线中程间变量值的传递均需要通过主内存来完成，主要通过JMM中定义基本8中操作来实现线程、主内存、工作内存三者的交互,关系如下图所示。(具体的JMM知识可参考[内存模型](1))
![线程内存交互](./imgs/线程内存交互.png)

&ensp; &ensp; 那么如何实现内存的可见性?即当写线程改写了共享变量的时候，而其他线程能够感知到变量改变了，同时在读取这个共享变量的时候，它是写线程写入的最新值。**总结起来，是指线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值**

&ensp; &ensp; Java中如何保证内存的可见性？java中提供了三种方:volatile、synchronized、final

* JMM(Java内存模型)之happens-before规则
&ensp; &ensp;是什么？是Java内存模型中定义的两项操作之间的偏序关系，如果说A行发生与操作B，其实就是说在发生操作B之前，操作A所产生的影响能够被B观察到，"影响"包括了修改内存中的个共享变量的值、发送了消息、调用了方法等。
规则的具体内容：
    - **程序次序规则**：在一个线程内，按照程序代码顺序，书写在前面的操作先发生与书写在后面的操作。此处的代码顺序更加确切的来说是控制流顺序，因为需要考虑分析、循环结构
    - **管程锁定规则**：一个unlock操作先生发生与后面对同一个锁的lock操作。需要强调的是必须是同一个锁，而"后面"是指时间上的先手顺序
    - **volatile变量规则**：对于一个volatile变量的写操作先行发生与后面对这个变量的读操作，这里的"后面"同样是指时间上的先后顺序
    - **线程启动规则**：Thread对象的start()方法先行发生与此线程的每一个动作
    - **线程终止规则**：线程中的所有操作都先行发生对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等于手动检测到线程已经终止执行
    - **线程中断规则**：对线程interrupt()方法的调用线性发生于呗中断线程的代码检测到中断时间的发生，可以通过Thread.interrupted()方法检测到是否有中断
    - **对象终结规则**：一个对象的初始化完成(构造函数执行结束)先行发生与它的finalize()方法的开始
    - **传递性**：如果操作A线程发生于操作B，操作B先行发生于操作C，那就可以的出操作A先行发生于操作C的结论
对于程序员关注最多的是：程序次序规则、管程锁定规则、volatile变量规则、传递性
&ensp; &ensp;如果相关操作满足上述规则，则不需要任何同步器协助即可保证操作的有序性，如果不在上述规则或者无法从上述规则中推导出来，那么就没有顺序性的保障。

* JMM(java内存模型)之as-if-serial语义
&ensp; &ensp; as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不会改变。编译器、runtime和处理器都必须遵守as-if-serial语义。为了遵守as-if-serial语义，**编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。**
例如：
    int a = 1; //操作A
    int b = 2; //操作B
    int s = a + b; //操作C

### 重排序
&ensp; &ensp;重排序通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段，(另外定义：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理)，重排序分为两类：编译器重排序和运行期重排序，分别对应编译时和运行时环境。
> int a = 10;
  int b = 15
  int c =   a + 1;
这三条语句，如果按照顺序一致性，执行顺序为①②③寄存器要被读写三次；但为了降低重复读写的开销，编译器会交换第二和第三的位置，即执行顺序为①③② 

执行重排序分为三种情况：
1.编译器优化的重排序，编译器在不改变单线程语义的前提下，可以重新安排语句的执行顺序。
2.指令级并行的重排序，如果数据之间不存在依赖性，处理器可以改变语句对应机器的执行顺序
3.内存系统的重排序，由于处理器使用缓存和读/写缓存，这使得加载和存储操作看上去可能是乱序在执行。
![重排序](./imgs/重排序.png)

但是同时又规as-if-serial语义，这样就导致了不管如何重排序，程序的执行结果是不会改变了。


## volatile 实现原理
从上面的分析，我们已经能够知道volatile的原理
1.**解决可见性**：在读操作时，JMM会把工作内存当中的变量设置为无效，要求线程直接从主内存当中读取；写操作时，会把修改过的变量更新到主内存中去，其他线程就会拿到主内存当中地最新值。因此可以看做是读线程与写线程都在主内存中操作。如下图
![volatile内存交互](./imgs/volatile内存交互.png)

2.**解决禁止指令重排序**：有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个**内存屏障**（指令重排序时不能把后面的指令重排序到内存屏障之前的位置)。重排序有三种，编译器重排序会按JMM的规范严格进行，换言之编译器重排序一般不会对程序的正确逻辑造成影响,第二、三步属于处理器重排序，处理器重排序JMM就不好管了，怎么办呢？它会要求java编译器在生成指令时加入内存屏障，内存屏障是什么？你可以理解为一个不透风的保护罩，把不能重排序的java指令保护起来，那么处理器在遇到内存屏障保护的指令时就不会对它进行重排序了。关于在哪些地方该加入内存屏障，内存屏障有哪些种类，各有什么作用，这些知识点这里就不再阐述了。可以参考JVM规范相关资料。
java中提供的内存屏障机制有四种：LoadLoad,StoreStore,LoadStore,StoreLoad
>**LoadLoad屏障**：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
**StoreStore屏障**：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
**LoadStore屏障**：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
**StoreLoad屏障**：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能


## volatile 性能
volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。

## volatile 适用的场景
目前只能推荐一篇文章,[volatile的适用场景][1],笔者目前没有使用经验，以后再做分享

## 参考链接
* [happens-before规则和as-if-serial语义](https://blog.csdn.net/u010571316/article/details/64906481)
* [volatile关键字详解](https://blog.csdn.net/kg_2012/article/details/79059909)
* [Java可见性机制的原理](https://www.cnblogs.com/humc/p/5426351.html)
* [Volatile关键字介绍](https://blog.csdn.net/summerZBH123/article/details/80547516)
* [Java中Volatile关键字详解](https://www.cnblogs.com/zhengbin/p/5654805.html)
* [JVM(十一)Java指令重排序](https://blog.csdn.net/yjp198713/article/details/78839698)
* [深入理解JVM（二）——内存模型、可见性、指令重排序](https://www.cnblogs.com/leefreeman/p/7356030.html)
* [JMM-volatile与内存屏障](https://blog.csdn.net/hqq2023623/article/details/51013468)
* [并发关键字volatile（重排序和内存屏障）](https://www.jianshu.com/p/ef8de88b1343)

[1]:(https://github.com/RedSpider1/concurrent/tree/article-2-1-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E9%99%88sir) "2.1Java内存模型基础知识"

[2]:(https://www.cnblogs.com/ouyxy/p/7242563.html)
"volatile的适用场景"

