# Thread类和Runnable接口

上一章我们了解了多线程的基本概念。那么在Java中，我们是如何使用多线程的呢？

首先，我们需要有一个“线程”类。JDK提供了`Thread`类和`Runnalble`接口来让我们实现自己的“线程”类。

- 继承`Thread`类，并覆盖`run`方法；
- 实现`Runnable`接口的`run`方法；

注意，`run`方法里面的内容代表我们要在这个线程里面执行的代码。`run`方法不需要我们显示调用，而是**留给JVM调用**的。

## 第一个Java多线程Demo

先学会怎么用，再学原理。首先我们来看看怎么用`Thread`和`Runnable`来写一个Java多线程程序。

```java
Thread threadA = new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("threadA");
    }
});
threadA.start();

// Java 8 函数式编程
Thread threadB = new Thread(() -> System.out.print("threadB"));
threadB.start();
```

注意要调用用`start()`方法后，该线程才算启动！

我们自己写的多线程任务，是继承`Thread`类好，还是实现`Runnable`接口好？

当然是实现`Runnable`接口！！！因为Thread类相比于`Runnable`类是非常大的，里面有很多对象和方法用来支持Thread类强大的功能。而我们实际上写自己的一个多线程任务时，是不需要这些对象和方法的，**线程当然是越轻量越好**，所以实现`Runnable`接口才是首选。

## Runnable接口

首先我们来看一下`Runnable`接口(JDK 1.8 +)：

```java
@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
```

可以看到`Runnable`是一个函数式接口，这意味着我们可以使用**Java 8的函数式编程**来简化代码。

## Thread类

`Thread`类是一个`Runnable`接口的实现类，首先我们来看看`Thread`类的源码。

### Thread类的构造方法

查看`Thread`类的构造方法，发现基本上是简单调用一个私有的`init`方法来实现初始化。我们来看看`init`的方法签名：

```java
// 片段1 - init方法
private void init(ThreadGroup g, Runnable target, String name,
                      long stackSize, AccessControlContext acc,
                      boolean inheritThreadLocals)

// 片段2 - 构造函数调用init方法
public Thread(Runnable target) {
    init(null, target, "Thread-" + nextThreadNum(), 0);
}

// 片段3 - 使用在init方法里初始化AccessControlContext类型的私有属性
this.inheritedAccessControlContext = 
    acc != null ? acc : AccessController.getContext();

// 片段4 - 两个对用于支持ThreadLocal的私有属性
ThreadLocal.ThreadLocalMap threadLocals = null;
ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;

```

我们挨个来解释一下这些参数：

- g：线程组，标识这个线程是在哪个线程组下；
- target：指定要执行的任务；
- name：线程的名字，多个线程的名字是可以重复的。如果不指定名字，见片段2；
- acc：见片段3，用于初始化私有变量`inheritedAccessControlContext`。这个变量有点神奇。它是一个私有变量，但是在`Thread`类里只有`init`方法对它进行初始化，在`exit`方法把它设为`null`。其它没有任何地方使用它。一般我们是不会使用它的，那什么时候会使用到这个对象呢？可以参考这个stackoverflow的问题：[Restrict permissions to threads which execute third party software](https://stackoverflow.com/questions/13516766/restrict-permissions-to-threads-which-execute-third-party-software)。
- inheritThreadLocals：可继承的`ThreadLocal`，见片段4，`Thread`类里面有两个私有属性来支持`ThreadLocal`，我们会在后面的章节介绍`ThreadLocal`的概念。

实际情况下，我们大多是直接调用下面两个构造方法：

```java
Thread(Runnable target)
Thread(Runnable target, String name)
```

### Thread类其它入门介绍

上面我们介绍了`Thread`类的构造方法和`start()`方法。接下来我们看一下`Thread`类的其它主要方法。

#### 优先级

线程是有优先级的。优先级高的线程，获得时间片的可能性比较大。这个是根据操作系统底层的算法来决定的。在Thread类中，定义了三个优先级常量：

```java
public final static int MIN_PRIORITY = 1;
public final static int NORM_PRIORITY = 5;
public final static int MAX_PRIORITY = 10;
```

Thread类提供了`setPriority(int newPriority)`方法，可以设置线程的优先级。在这个方法里，检查了传入的优先级不能小于1，也不能大于10。而且受当前线程组的约束，如果超过了线程组允许的最大优先级，会重新设置为线程组的最大优先级。

注意，设置成大的优先级并代表线程就一定能优先执行！操作系统只是把Java设置的优先级作为一个建议，它也完全可以忽略这个值。

#### 线程状态

不同于上一章介绍到的线程在”**操作系统里的状态**“，Java里面也有一个线程的状态。注意，**Java的线程状态与操作系统的线程状态是不同的**。

`Thread`类里面有一个`public`的内部枚举类，用于标识线程的状态。其结构如下：

```java
public enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;
}
```

我们会在后续的“**线程通信基础**”章节来详细解释线程的状态以及它们之间的转化关系和常用的方法。

# Callable与Future、FutureTask

通常来说，我们使用`Runnable`和`Thread`来创建一个新的线程。但是它们有一个弊端，就是`run`方法是没有返回值的。而有时候我们希望开启一个线程去执行一个任务，并且这个任务执行完成后有一个返回值。

JDK提供了`Callable`接口与`Future`类为我们解决这个问题。

## Callable接口

`Callable`与`Runnable`一样，同样是只有一个抽象方法的函数式接口。不同的是，`Callable`的这个唯一方法是**有返回值**的，而且支持**泛型**。另外一个区别是它可以显示地抛出一个异常。

```java
@FunctionalInterface
public interface Callable<V> {
    V call() throws Exception;
}

```

那一般是怎么使用`Callable`的呢？`Callable`一般是配合线程池工具`ExecutorService`来使用的。我们会在第三篇内容详细解释线程池的使用。这里只介绍`ExecutorService`可以使用`submit`方法来让一个`Callable`接口执行。它会返回一个`Future`，我们后续的程序可以通过这个`Future`的`get`方法得到结果。

这里可以看一个简单的使用demo：

```java
// 自定义Callable
class Task implements Callable<Integer>{
    @Override
    public Integer call() throws Exception {
        // 模拟计算需要一秒
        Thread.sleep(1000);
        return 2;
    }
}

// 使用
ExecutorService executor = Executors.newCachedThreadPool();
Task task = new Task();
Future<Integer> result = executor.submit(task);
// 注意调用get方法会阻塞当前线程，直到得到结果。
// 所以实际编码中建议使用可以设置超时时间的重载get方法。
System.out.println(result.get()); 

```

## Future接口

`Future`接口只有几个比较简单的方法：

```java
public abstract interface Future<V> {
    public abstract boolean cancel(boolean paramBoolean);
    public abstract boolean isCancelled();
    public abstract boolean isDone();
    public abstract V get() throws InterruptedException, ExecutionException;
    public abstract V get(long paramLong, TimeUnit paramTimeUnit)
            throws InterruptedException, ExecutionException, TimeoutException;
}
```

除了上述提到的`get`方法外，`Future`还可以去试图去取消一个任务的执行，还有判断是否取消成功和是否执行完毕。

注意是**试图**取消，**并不一定能取消成功**。因为任务可能已完成、已取消、或者一些其它因素不能取消，存在取消失败的可能。返回值就是是否取消成功的意思。参数`paramBoolean`表示是否采用中断的方式取消线程执行。

所以有时候，为了让任务有能够取消的功能，就使用`Callable`来代替`Runnable`。如果为了可取消性而使用 `Future `但又不提供可用的结果，则可以声明 `Future<?> `形式类型、并返回 `null `作为底层任务的结果。

## FutureTask类

上面介绍了`Future`接口。这个接口有一个实现类叫`FutureTask`。`FutureTask`是实现的`RunnableFuture`接口的，而`RunnableFuture`接口同时继承了`Runnable`接口和`Future`接口：

```java
public interface RunnableFuture<V> extends Runnable, Future<V> {
    /**
     * Sets this Future to the result of its computation
     * unless it has been cancelled.
     */
    void run();
}
```

那`FutureTask`类有什么用？为什么要有一个`FutureTask`类？前面说到了`Future`只是一个接口，而它里面的`cancel`，`get`，`isDone`等方法要自己实现起来都是**非常复杂**的。所以JDK提供了一个`FutureTask`类来供我们使用。

先上代码：

```java
// 自定义Callable，与上面一样
class Task implements Callable<Integer>{
    @Override
    public Integer call() throws Exception {
        // 模拟计算需要一秒
        Thread.sleep(1000);
        return 2;
    }
}

// 使用
ExecutorService executor = Executors.newCachedThreadPool();
FutureTask<Integer> futureTask = new FutureTask<>(new Task());
executor.submit(futureTask);
System.out.println(futureTask.get());
```

使用上与第一个Demo有一点小的区别。首先，调用`submit`方法是没有返回值的。这里实际上是调用的`submit(Runnable task)`方法，而上面的Demo，调用的是`submit(Callable<T> task)`方法。

然后，这里是使用`FutureTask`直接取`get`取值，而上面的Demo是通过`submit`方法返回的`Future`去取值。

在很多高并发的环境下，往往我们只需要某些任务只执行一次。这种使用情景`FutureTask`的特性恰能胜任（详情请看`FutureTask`的`run`方法源码），`FutureTask`能够在高并发环境下**确保任务只执行一次**。

以上就是Java多线程几个基本的类和接口的介绍。可以打开JDK看看源码，体会这几个类的设计思路和用途吧！

# 参考文章

1. [Java语言定义的线程状态分析](https://www.cnblogs.com/trust-freedom/p/6606594.html)

