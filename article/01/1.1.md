## 产生进程背景
最初的计算机只能接受一些特定的指令，用户输入一个指令，计算机就做出一个操作。当用户在思考或者输入时，计算机就在等待。显然这样效率低下，在很多时候，计算机都处在等待状态。提高效率方式：**批处理操作体统**,把一系列需要操作的指令写下来，形成一个清单，一次性交给计算机。用户将多个需要执行的程序写在磁带上，然后交由计算机去读取并逐个执行这些程序，并将输出结果写在另一个磁带上。由于批处理操作系统的指令运行方式是串行的，效率不高。
批处理操作系统问题解决方式：通过对AB执行动态切换有效的使用CPU。在A进行IO操作的时候，让CPU去B去,当IO操作结束,让B暂停，再让CPU执行A。通过这样的切换方式实现对CPU资源的高效利用。由此产生进程，每个进程来对应一定的内存地址空间，自己独享与其他线程互不干预；
当解决了进程解决了操作系统的并发后，对于进程实时性有了要求，就产生了线程，让一个线程执行一个子任务，这样一个进程就包含了多个线程，每个线程负责一个单独的子任务。  

## 上下文切换
上下文切换（有时也称做进程切换或任务切换）是指 CPU 从一个进程或线程切换到另一个进程或线程。上下文是指**某一时间点 CPU 寄存器和程序计数器的内容。**
寄存器是cpu内部的少量的速度很快的闪存，通常存储和访问计算过程的中间值提高计算机程序的运行速度。程序计数器是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体实现依赖于特定的系统
>举例说明 线程A - B
1.先挂起线程A，将其在cpu中的状态保存在内存中
2.在内存中检索下一个线程B的上下文并将其在 CPU 的寄存器中恢复,执行B线程
3.当B执行完，根据程序计数器中指向的位置恢复线程A

CPU通过为每个线程分配CPU时间片来实现多线程机制。CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。

## 程序 进程 线程
  + 程序：用某种编程语言(java、python等)编写，能够完成一定任务或者功能的代码集合,是指令和数据的有序集合，是**一段静态代码**
  + 进程：是**一个执行中的程序的实例,是程序的执行过程,是程序在内存中的一种映射，是操作系统资源管理的最小单位**。系统的中的每个程序都运行在某个进程的上下文(context)中。上下文是由程序运行所需的状态组成，包括：存放在内部的程序代码、数据、它的栈、通用目的的寄存器内容、程序计数器、环境变量以及打开描述符的集合
  + 线程：线程是能并行运行并且与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）和其他资源的轻量级的进程。
> **举例说明**：进程是一条多车道的高速，而它里面的线程就是车道上的车，各个车（线程）共用车道，他们之间有的快，有的慢，有的车会一起“出发”（就绪状态），有的车会在路上堵车（堵塞状态），更多的车都在正常前进（运行状态）

## 线程的状态及生命周期(结合图转换，重在理解)

![线程的状态及交互](./imgs/status.png)

* **新建状态**：(new)线程被创建,但是未申请到资源，比如所需内存
* **就绪状态**：(start)线程做好了一切准备(资源申请),位于**可运行池中**,等待系统调度，获取cpu时间片
* **执行状态**：(run)线程获取到了cpu时间片，进行执行。当一个线程启动后，它不能一直处于运行状态（除非它的线程执行体足够短，瞬间结束），当使用完系统分配的时间后,系统就会剥脱该线程占用的CPU资源，让其他线程获得时间片以执行。**只有处于就绪状态的线程才可能转换到运行状态**
* **阻塞状态**: 等待其他事件发生才能执行,join()方法或者wait()方法,比如执行耗时的I/O读写。
  - **等待阻塞**:运行的线程执行wait()方法或者join()方法，该线程会释放占用的所有资源，JVM会把该线程放入**等待池**中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒。
  - **同步阻塞**:运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入**锁池**中。
  - **其他阻塞**:运行的线程执行sleep()，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
* **终止状态**：线程的run()方法正常执行完毕或者线程抛出一个未捕获的异常（Exception）、错误（Error），线程就进入死亡状态。一旦进入死亡状态，线程将不再拥有运行的资格，也不能转换为其他状态


## 参考链接 
- [线程的几种状态转换](http://www.cnblogs.com/jijijiefang/articles/7222955.html)
- [进程和线程的由来与别](https://blog.csdn.net/whl_program/article/details/70217354)
- [进程、线程、多线程相关总结](https://www.cnblogs.com/fuchongjundream/p/3829508.html)
- [进程的概念/标识/结构/状态](https://blog.csdn.net/derkampf/article/details/60477317)
- [操作系统 - 进程的概念](http://www.cnblogs.com/tianlangshu/p/5224178.html)
- [进程管理笔记一、进程的概念及其产生的背景](https://blog.csdn.net/xd_hebuters/article/details/79590441#一进程产生的背景)
- [上下文切换](http://ifeve.com/context-switch-definition/)
- [进程的概念/标识/结构/状态](https://blog.csdn.net/derkampf/article/details/60477317)
- [线程的生命周期及状态转换详解](https://blog.csdn.net/asdf_1024/article/details/78978437)
- [进程与线程](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319272686365ec7ceaeca33428c914edf8f70cca383000) 
