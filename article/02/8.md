# 第八章 volatile

## 8.1 几个基本概念

在介绍volatile之前，我们先回顾及介绍几个基本的概念。

### 8.1.1 内存可见性

在Java内存模型那一章我们介绍了JMM有一个主内存，每个线程有自己私有的工作内存，工作内存中保存了一些变量在主内存的拷贝。

**内存可见性，指的是线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值**。

### 8.1.2 重排序

为优化程序性能，对原有的指令执行顺序进行优化重新排序。重排序可能发生在多个阶段，比如编译重排序、CPU重排序等。

### 8.1.3 happens-before规则

是一个给程序员使用的规则，只要程序员在写代码的时候遵循happens-before规则，JVM就能保证指令在多线程之间的顺序性符合程序员的预期。

## 8.2 volatile的内存语义

在Java中，volatile关键字有特殊的内存语义。volatile主要有以下两个功能：

- 保证变量的**内存可见性**
- 禁止volatile变量与普通变量**重排序**（JSR133提出，Java 5 开始才有这个“增强的volatile内存语义”）

### 8.2.1 内存可见性

以一段示例代码开始：

```java
public class VolatileExample {
    int a = 0;
    volatile boolean flag = false;
    
    public void writer() {
        a = 1; // step 1
        flag = true; // step 2
    }
    
    public void reader() {
        if (flag) { // step 3
            System.out.println(a); // step 4
        }
    }
}
```

在这段代码里，我们使用`volatile`关键字修饰了一个`boolean`类型的变量`flag`。

所谓内存可见性，指的是当一个线程对`volatile`修饰的变量进行**写操作**（比如step 2）时，JMM会立即把该线程对应的本地内存中的共享变量的值刷新到主内存；当一个线程对`volatile`修饰的变量进行**读操作**（比如step 3）时，JMM会把立即该线程对应的本地内存置为无效，从主内存中读取共享变量的值。

> 在这一点上，volatile与锁具有相同的内存效果，volatile变量的写和锁的释放具有相同的内存语义，volatile变量的读和锁的获取具有相同的内存语义。

假设在时间线上，线程A先自行方法writer方法，线程B后执行reader方法。那必然会有下图：

![volatile内存示意图](.\imgs\volatile内存示意图.jpg)

而如果`flag`变量**没有**用`volatile`修饰，在step 2，线程A的本地内存里面的变量就不会立即更新到主内存，那随后线程B也同样不会去主内存拿最新的值，仍然使用线程B本地内存缓存的变量的值`a = 0，flag = false`。









2.**解决禁止指令重排序**：有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个**内存屏障**（指令重排序时不能把后面的指令重排序到内存屏障之前的位置)。重排序有三种，编译器重排序会按JMM的规范严格进行，换言之编译器重排序一般不会对程序的正确逻辑造成影响,第二、三步属于处理器重排序，处理器重排序JMM就不好管了，怎么办呢？它会要求java编译器在生成指令时加入内存屏障，内存屏障是什么？你可以理解为一个不透风的保护罩，把不能重排序的java指令保护起来，那么处理器在遇到内存屏障保护的指令时就不会对它进行重排序了。关于在哪些地方该加入内存屏障，内存屏障有哪些种类，各有什么作用，这些知识点这里就不再阐述了。可以参考JVM规范相关资料。
java中提供的内存屏障机制有四种：LoadLoad,StoreStore,LoadStore,StoreLoad

>**LoadLoad屏障**：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
**StoreStore屏障**：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
**LoadStore屏障**：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
**StoreLoad屏障**：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能


## volatile 性能
volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。

## volatile 适用的场景
由于synchronized有一定的性能问题，而volatile关键字在某些情况下优于synchronized，但是由于volatile无法保证原子性，volatile 通常做某个操作完成、发生中断、或者状态的标志,因此在使用volatile时需要具备以下条件：
    1 对变量的写操作不依赖于当前值，或者你能确保只有单个线程更新变量的值(自增操作、自减操作)
    2 该变量不会与其他变量一起纳入不变性条件中(volatile变量不能用于约束条件中)
    3 在访问变量时不需要加锁(加锁机制既可以保证可见性又可以保证原子性，而volatile变量只能确保可见性)
    以上条件也就限制了,可以被写入volatile变量的**这些有效值独立于任何程序的状态**，包含变量的当前状态。

### 场景一：状态标志
实现 volatile 变量的规范使用仅仅是使用一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或请求停机。
示例代码1：
```java
public class TestVolatile {
	public static void main(String[] args) {
		TestThread1 thread = new TestThread1();
		new Thread(thread).start();
		while(true) {
			if(thread.getFlag()) {
				System.out.println("over!!!");
				break;
			}
		}
	}
}
class TestThread1 implements Runnable{
	private  boolean flag = false; 
	@Override
	public void run() {
		try {
			Thread.sleep(200);
		} catch (Exception e) {
		}
		flag = true;
		System.out.println("flag=" + getFlag());
	}
	public boolean getFlag() {
		return flag;
	}
	
}
```
示例代码一运行了以后发现，控制台会输出flag=true后程序无法结束，问题在于主线程对于共享变量flag读取到flag = true,因此主线程就一直处于循环中

示例代码2：
```java
    public class TestVolatile {
	public static void main(String[] args) {
		TestThread1 thread = new TestThread1();
		new Thread(thread).start();
		while(true) {
			if(thread.getFlag()) {
				System.out.println("over!!!");
				break;
			}
		}
	}
}
class TestThread1 implements Runnable{
	private volatile boolean flag = false;  //使用volatile关键字修饰共享变量false,当此变量改变时其他线程会感知到其最新的值
	@Override
	public void run() {
		try {
			Thread.sleep(200);
		} catch (Exception e) {
		}
		flag = true;
		System.out.println("flag=" + getFlag());
	}
	public boolean getFlag() {
		return flag;
	}
}
```
console:
over!!!
flag=true

示例代码2运行了以后会发现输出上述内容以后就程序就停止了。这就是volatile关键字保证了共享变量的内存可见性，当thread线程改变了共享变量flag值以后，main线程会感知到，并且获取到共享变量的最新值，从而跳出循环，结束程序

### 一次性安全发布（one-time safe publication）
在缺乏同步的情况下，可能会遇到某个对象引用的更新值（由另一个线程写入）和该对象状态的旧值同时存在。
这就是造成著名的双重检查锁定（double-checked-locking）问题的根源，其中对象引用在没有同步的情况下进行读操作，产生的问题是您可能会看到一个更新的引用，但是仍然会通过该引用看到不完全构造的对象。如下面介绍的单例模式。
```java
    private volatile static Singleton instace;     
    public static Singleton getInstance(){     
        //第一次null检查       
        if(instance == null){              
            synchronized(Singleton.class) {    //1       
                //第二次null检查         
                if(instance == null){          //2    
                    instance = new Singleton();//3    
                }    
            }             
        }    
        return instance;   
    }
```

## 参考链接
* [happens-before规则和as-if-serial语义](https://blog.csdn.net/u010571316/article/details/64906481)
* [volatile关键字详解](https://blog.csdn.net/kg_2012/article/details/79059909)
* [Java可见性机制的原理](https://www.cnblogs.com/humc/p/5426351.html)
* [Volatile关键字介绍](https://blog.csdn.net/summerZBH123/article/details/80547516)
* [Java中Volatile关键字详解](https://www.cnblogs.com/zhengbin/p/5654805.html)
* [JVM(十一)Java指令重排序](https://blog.csdn.net/yjp198713/article/details/78839698)
* [深入理解JVM（二）——内存模型、可见性、指令重排序](https://www.cnblogs.com/leefreeman/p/7356030.html)
* [JMM-volatile与内存屏障](https://blog.csdn.net/hqq2023623/article/details/51013468)
* [并发关键字volatile（重排序和内存屏障）](https://www.jianshu.com/p/ef8de88b1343)

[1]:(https://github.com/RedSpider1/concurrent/tree/article-2-1-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-%E9%99%88sir) "2.1Java内存模型基础知识"

[2]:(https://www.cnblogs.com/ouyxy/p/7242563.html)
"volatile的适用场景"
