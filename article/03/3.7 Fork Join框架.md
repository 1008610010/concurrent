# 大纲

- 什么是Fork/Join
- 工作窃取算法
- Fork/Join具体实现
  - ForkJoinTask
    - 几个方法
    - RecursiveTask和RecursiveAction
  - ForkJoinPool
    - execute/submit/invoke提交任务

## 什么是Fork/Join

> Fork/Join框架是一个实现了ExecutorService接口的多线程处理器，它专为那些可以通过递归分解成更细小的任务而设计，最大化的利用多核处理器来提高应用程序的性能。
>
> 与其他ExecutorService相关的实现相同的是，Fork/Join框架会将任务分配给线程池中的线程。而与之不同的是，Fork/Join框架在执行任务时使用了工作窃取算法。



fork在英文里有分叉的意思，join在英文里连接、结合的意思。顾名思义，fork就是要使一个大任务分解成若干个小任务，而join就是最后将各个小任务的结果结合起来得到大任务的结果。

fork/join的运行流程大致如下所示：

![fork/join流程图](../img/fork_join流程图.png)

需要注意的是，图里的次级子任务可以一直分下去，一直分到子任务足够小为止。用伪代码来表示如下：

```pseudocode
solve(任务):
    if(任务已经划分到足够小):
        顺序执行任务
    else:
    	for(划分任务得到子任务)
    		solve(子任务)
    	结合所有子任务的结果到上一撑循环
    	return 最终结合的结果
```

通过上面伪代码可以看出，我们通过递归嵌套的计算得到最终结果，这里有体现**分而治之(divide and conquer)** 的算法思想。

## 工作窃取算法

> 工作窃取算法指的是在多线程执行不同任务队列的过程中，某个线程执行完自己队列的任务后从其他线程的任务队列里窃取任务来执行。

工作窃取流程如下图所示：

![工作窃取算法流程](../img/工作窃取算法运行流程图.png)

值得注意的是，当一个线程窃取另一个线程的时候，为了减少两个任务线程之间的竞争，我们通常使用双端队列来存储任务。被窃取的任务线程都从双端队列的头部拿任务执行，而窃取其他任务的线程从双端队列的尾部执行任务。

另外，当一个线程在窃取任务时要是没有其他可用的任务了，这个线程会进入**阻塞状态**以等待再次“工作”。

## Fork/Join的具体实现

前面我们说Fork/Join框架简单来讲就是对任务的分割与子任务的合并，所以要实现这个框架，先得有任务。在Fork/Join框架里提供了抽象类ForkJoinTask来实现任务。

### ForkJoinTask

> ForkJoinTask是一个类似普通线程的实体，但是比普通线程轻量得多。

#### 几个主要方法

- fork()：使用线程池中的空闲线程异步执行此任务

```java
public final ForkJoinTask<V> fork() {
    Thread t;
    // ForkJoinWorkerThread是执行ForkJoinTask的专有线程，由ForkJoinPool管理
    // 先判断当前线程是否是ForkJoin专有线程，如果是，则将任务push到当前线程所负责的队列里去
    if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)
        ((ForkJoinWorkerThread)t).workQueue.push(this);
    else
     	// 如果不是ForkJoinWorkerThread类型的线程，则通过ForkJoinPool里的externalPush方法将线程加入队列
        ForkJoinPool.common.externalPush(this);
    return this;
}
```

> 注：本文所有代码都引用于Java8

其实fork()只做了一件事，那就是**把任务推入当前工作线程的工作队列里**。

- join()：等待处理任务的线程处理完毕，获得返回值

来看下join()的源码：

```java
public final V join() {
    int s;
    // doJoin()方法来获取当前任务的执行状态
    if ((s = doJoin() & DONE_MASK) != NORMAL)
        // 任务异常，抛出异常
        reportException(s);
    // 任务正常完成，获取返回值
    return getRawResult();
}

/**
 * doJoin()方法用来返回当前任务状态
 **/
private int doJoin() {
    int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;
    // 先判断任务是否执行完毕，执行完毕直接返回结果（执行状态）
    return (s = status) < 0 ? s :
    // 如果没有执行完毕，先判断是否是ForkJoinWorkThread线程
    ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?
        // 如果是，先判断任务是否处于工作队列顶端（意味着下一个就执行它）
        // tryUnpush()方法判断任务是否处于当前工作队列顶端，是返回true
        // doExec()方法执行任务
        (w = (wt = (ForkJoinWorkerThread)t).workQueue).
        // 如果是处于顶端并且任务执行完毕，返回结果
        tryUnpush(this) && (s = doExec()) < 0 ? s :
        // 如果不是顶端，那就调用awitJoin()
        // awaitJoin()：使用自旋使任务执行完成，返回结果
        wt.pool.awaitJoin(w, this, 0L) :
    // 如果不是ForkJoinWorkThread线程，执行externalAwaitDone()返回任务结果
    externalAwaitDone();
}
```



通常情况下，在创建任务的时候我们一般不直接继承ForkJoinTask，而是继承它的子类**RecursiveAction**和**RecursiveTask**。

#### RecursiveAction和RecursiveTask

两个都是ForkJoinTask的子类，**RecursiveAaction可以看做是无返回值的ForkJoinTask，RecursiveRask是有返回值的ForkJoinTask**。

此外，两个子类都有执行主要计算的方法compute()，当然，RecursiveAction的compute()返回空，RecursiveTask的compute()有具体的返回值。

### ForJoinPool

> ForkJoinPool是用于执行ForkJoinTask任务的执行（线程）池。
>
> ForkJoinPool管理着执行池中的线程和任务队列，此外，执行池是否还接受任务，显示线程的运行状态也是在这里处理。

#### 几个概念

- WorkQueue：双向队列，用于任务的执行。如果是自己的线程执行，则从顶端开始执行(LIFO)；如果是其他线程窃取执行，则从尾端开始执行；

> ForkJoinPool与传统线程池最显著的区别就是它维护了一个队列数组（volatile WorkQueue[] workQueues）。

- ForkJoinWorkerThread：执行ForkJoinTask的专有线程；



# 参考

[Wikipedia](https://en.wikipedia.org/wiki/Fork%E2%80%93join_model)

[聊聊并发（八）——Fork/Join 框架介绍](https://www.infoq.cn/article/fork-join-introduction)

[浅谈Java的Fork/Join并发框架](https://my.oschina.net/jack90john/blog/1501634)

[[Fork/Join 框架-设计与实现（翻译自论文《A Java Fork/Join Framework》原作者 Doug Lea）](https://www.cnblogs.com/suxuan/p/4970498.html)](https://www.cnblogs.com/suxuan/p/4970498.html)

[Java 并发编程笔记：如何使用 ForkJoinPool 以及原理](http://blog.dyngr.com/blog/2016/09/15/java-forkjoinpool-internals/)

[jdk1.8-ForkJoin框架剖析](https://www.jianshu.com/p/f777abb7b251)

[[Fork-Join 原理深入分析（二）](https://www.cnblogs.com/jinggod/p/8490573.html)

