# 线程池

## 为什么要使用线程池

1. 创建/销毁线程需要消耗系统资源，线程池可以复用已创建的线程。
2. 控制并发的数量。并发数量过多，可能会导致内存消耗过多，从而造成服务器崩溃。
3. 可以对线程做统一管理。

##  线程池的原理

Java中的线程池顶层接口是Executor接口，ThreadPoolExecutor 是这个接口的实现类。

我们先看看ThreadPoolExecutor 类。

### ThreadPoolExecutor 提供的构造方法

一共有四个构造方法：

```java
//五个参数的构造函数
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue)

//六个参数的构造函数-1
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory)

//六个参数的构造函数-2
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          RejectedExecutionHandler handler)

//七个参数的构造函数
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)

```

涉及到5~7个参数，我们先看看必须的5个参数是什么意思：

* **int  corePoolSize** 

  该线程池中**核心线程数最大值** 

  > 核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（铁饭碗），而非核心线程如果长时间的闲置，就会被销毁（临时工）。

* **int maximumPoolSize** 

  该线程池中**线程总数最大值** 。

  > 该值等于核心线程数量+非核心线程数量。

* **long keepAliveTime** 

  **非核心线程闲置超时时长**。

  > 非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut = true，则会作用于核心线程 。

* **TimeUnit unit** 

  keepAliveTime的单位，TimeUnit是一个枚举类型 ，包括以下：

  ```java
  NANOSECONDS ： 1微毫秒 = 1微秒 / 1000
  MICROSECONDS ： 1微秒 = 1毫秒 / 1000
  MILLISECONDS ： 1毫秒 = 1秒 /1000
  SECONDS ： 秒
  MINUTES ： 分
  HOURS ： 小时
  DAYS ： 天
  ```

* **BlockingQueue workQueue** 

  该线程池中的任务队列：维护着等待执行的Runnable任务对象。

  常用的worksQueue有：

  1. **SynchronousQueue** 

     SynchronousQueue是无缓冲等待队列，**不会保留任务**，会直接把任务交给线程去执行。必须等待队列中的任务被线程执行后才能继续在任务队列中添加新的任务。如果所有的线程都在工作，那么就新建线程。

     一般设定maximumPoolSize=Integer.MAX_VALUE，这样做是为了避免线程数增多，数量超过maximumPoolSize而抛出异常。

  2. **LinkedBlockingQueue**

     LinkedBlockingQueue是一个无界缓存等待队列。如果当前线程数小于核心线程数，则新建核心线程处理任务；如果当前线程数等于核心线程数，则进入队列等待。

     由于这个队列没有最大值限制，即所有超过核心线程数的任务都将被添加到队列中，这也就导致了maximumPoolSize的设定失效，因为总线程数永远不会超过corePoolSize。

  3. **ArrayBlockingQueue** 

     ArrayBlockingQueue是一个有界缓存等待队列，可以指定缓存队列的大小，当正在执行的线程数等于corePoolSize时，多余的任务缓存在ArrayBlockingQueue队列中，等待核心线程空闲后继续执行。当ArrayBlockingQueue已满时，会开启非核心线程去执行，当线程总数已经达到最大的maximumPoolSizes时，再有新的元素尝试加入ArrayBlockingQueue时会报错。

好了，介绍完5个必须的参数之后，还有两个打酱油的参数，大家知道有这么回事就行，平时基本用不到。

* **ThreadFactory threadFactory** 

  创建线程的方式 

* **RejectedExecutionHandler handler** 

  拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略，四种策略为 ：

  ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 
  ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
  ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
  ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 

### ThreadPoolExecutor的策略

线程池本身也是一个线程，这个线程就是用于管理布控整个线程池里的各种任务和事务，例如创建线程、销毁线程、任务队列管理、线程队列管理等等。 

故线程池也有自己的状态。ThreadPoolExecutor类中定义了一个volatile变量runState来表示线程池的状态 ，分别为RUNNING、SHURDOWN、STOP、TERMINATED。 

- 线程池创建后处于RUNNING状态。
- 调用shutdown后处于SHUTDOWN状态，线程池不能接受新的任务，会等待缓冲队列的任务完成。
- 调用shutdownNow后处于STOP状态，线程池不能接受新的任务，并尝试终止正在执行的任务。
- 当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。

#### 线程池主要的任务处理流程

处理任务的核心方法是execute(Runnabel command) ，我们看看ThreadPoolExecutor是如何处理线程任务的：

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    //如果线程数大于等于基本线程数或者线程创建失败，将任务加入队列
    if (poolSize >= corePoolSize || !addIfUnderCorePoolSize(command)) {
        //线程池处于运行状态并且加入队列成功
        if (runState == RUNNING && workQueue.offer(command)) {
            if (runState != RUNNING || poolSize == 0)
                ensureQueuedTaskHandled(command);
        }
        //线程池不处于运行状态或者加入队列失败，则创建线程（创建的是非核心线程）
        else if (!addIfUnderMaximumPoolSize(command))
            //创建线程失败，则采取阻塞处理的方式
            reject(command); 
    }
}
```

总结一下处理流程：

1. 线程总数量<corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量<corePoolSize时）。**注意，这一步需要获得全局锁。**
2. 线程总数量>=corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了线程复用）。 
3. 当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。**注意，这一步需要获得全局锁。**
4. 缓存队列满了， 总线程数又达到了maximumPoolSize，则会采取上面提到的拒绝策略RejectedExecutionHandler 进行处理。

整个过程如图所示：

![](https://raw.githubusercontent.com/chenxiao19920206/RedSpiderArticlePhotos/master/java-base/multi-thread/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%BB%E8%A6%81%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png)

#### ThreadPoolExecutor如何做到线程复用的？

我们知道，一个线程有一个run方法，在线程创建的时候，这个run方法就已经与这个线程绑定了（想想线程的创建方式），当执行完run方法之后，线程自动销毁。**那么，线程池如何做到线程复用呢？**

原来，ThreadPoolExecutor在创建线程时，会将线程封装成**工作线程worker**,并放入**工作线程组**中（区别任务队列），我们看看worker类的部分源码：

```java
private final class Worker implements Runnable {
    private final ReentrantLock runLock = new ReentrantLock();
    private Runnable firstTask;
    volatile long completedTasks;
    Thread thread;//成员变量
    Worker(Runnable firstTask) {
        this.firstTask = firstTask;
    }
    //以下代码省略
    ...
}
```

看到了吗，Thread作为成员变量封装在了worker类中，同时，worker类还有一个成员变量firstTask是runnable类型，这个就是worker被创建时需要执行的第一个任务。

Worker类实现了Runnable接口，那么必然实现了run方法，我们看看他的run方法：

```java
public void run() {
        try {
            Runnable task = firstTask;
            firstTask = null;
            while (task != null || (task = getTask()) != null) {
                runTask(task);
                task = null;
            }
        } finally {
            workerDone(this);   //当任务队列中没有任务时，进行清理工作       
        }
    }
```

首先去执行创建这个works时就有的线程任务，当执行完这个线程任务后，worker的生命周期并没有结束，在while循环中，worker会不断地调用getTask方法从**任务队列**中获取任务然后执行,从而达到**复用线程**的目的。

当然，核心线程池中创建的线程想要拿到任务队列中的任务，先要判断线程池的状态：

* 如果STOP或者TERMINATED，返回NULL，
* 如果是RUNNING或者SHUTDOWN，则从任务队列中拿到任务去执行。 



### 四种常见的线程池

一般情况下，我们不直接使用`new ThreadPoolExecutor`来创建线程池，而是使用Executor类中提供的几个静态方法来创建线程池。如果看懂了前面讲的ThreadPoolExecutor构造方法中各种参数的意义，那么一看到Executor类中提供的线程池的源码就应该知道这个线程池是干嘛的。

* **Executor.newCachedThreadPool()**

  ```java
  public static ExecutorService newCachedThreadPool() {
      return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                    60L, TimeUnit.SECONDS,
                                    new SynchronousQueue<Runnable>());
  }
  ```

  CacheThreadPool 的**运行流程**如下：

  1. 提交任务进线程池。
  2. 因为 corePoolSize 为0的关系，不创建核心线程。
  3. 尝试将任务添加到 SynchronousQueue 队列。
  4. 如果SynchronousQueue 入列成功，等待被当前运行的线程空闲后拉取执行。如果当前没有空闲线程，那么就创建一个非核心线程，然后从 SynchronousQueue 拉取任务并在当前线程执行。
  5. 如果 SynchronousQueue 已有任务在等待，入列失败。因为 maximumPoolSize 无上限的原因，创建新的非核心线程来执行任务。《---代码验证是否是这样

  当需要执行很多**短时间**的任务时，CacheThreadPool 的线程复用率比较高， 会显著的**提高性能**。而且线程60s后会回收，意味着即使没有任务进来，CacheThreadPool 并不会占用很多资源。 

* **Executor.newFixedThreadPool()**

  ```java
  public static ExecutorService newFixedThreadPool(int nThreads) {
          return new ThreadPoolExecutor(nThreads, nThreads,
                                        0L, TimeUnit.MILLISECONDS,
                                        new LinkedBlockingQueue<Runnable>());
  }
  ```

  这是一个有着固定线程数量且使用无界队列作为线程队列的线程池。如果有新的任务提交，但是没有线程可用，这个任务会一直等待直到有可用的线程。 

  **与CachedThreadPool的区别**

  * 相同点：都使用无界队列，意味着可用一直向线程池提交任务，不会触发拒绝策略。
  * 不同点
    *  因为 corePoolSize == maximumPoolSize ，所以FixedThreadPool只会创建核心线程。 CachedThreadPool因为corePoolSize=0，所以只会创建非核心线程。
    * 在 getTask() 方法，如果队列里没有任务可取，线程会一直阻塞在 LinkedBlockingQueue.take() ，线程不会被回收。 CachedThreadPool会在60s后收回。
    * 由于线程不会被回收，会一直卡在阻塞，所以没有任务的情况下， FixedThreadPool 占用资源更多。 

* **Executor.newSingleThreadExecutor()**

  ```java
  public static ExecutorService newSingleThreadExecutor() {
      return new FinalizableDelegatedExecutorService
          (new ThreadPoolExecutor(1, 1,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>()));
  }
  ```

  有且仅有一个核心线程（ corePoolSize == maximumPoolSize=1），使用了LinkedBlockingQueue（容量无限大），所以，不会创建非核心线程。所有任务按照先来先执行的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。

从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。 实际中，如果Executor类提供的创建线程的静态方法能够满足需要，尽量使用它提供的方法。如果达不到要求，可以自己继承ThreadPoolExecutor类进行重写。

## 线程池的使用

可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。 

execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。    

```java
threadsPool.execute(new Runnable(){
   					 @override
    				public void run(){
         
    				}
});
```

submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个 future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方 法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线 程一段时间后立即返回，这时候有可能任务没有执行完。    

```java
Future<Object> future = executor.submit(harReturnValuetask);
    try {
    Object s = future.get();
    } catch (InterruptedException e) {
    // 处理中断异常
    } catch (ExecutionException e) {
    // 处理无法执行任务异常
    } finally {
    // 关闭线程池
    executor.shutdown();
}
```

---此处有代码检验get



## 参考资料

1. [线程池，这一篇或许就够了](https://blog.csdn.net/lift_class/article/details/70216690)
2. [线程池的使用](https://www.cnblogs.com/zzuli/p/9386463.html)
3. 《并发编程的艺术》
4. [线程池院系详解一](https://www.cnblogs.com/dongguacai/p/6030187.html)
5. [Java线程池复用的秘密](https://blog.csdn.net/c10WTiybQ1Ye3/article/details/80428945)

