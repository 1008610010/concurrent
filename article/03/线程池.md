# 线程池

## 为什么要使用线程池

1. 创建/销毁线程需要消耗系统资源，线程池可以复用已创建的线程。
2. 控制并发的数量。并发数量过多，可能会导致内存消耗过多，从而造成服务器崩溃。
3. 对线程做统一管理。

##  线程池的原理

Java中的线程池的概念是在Executor这个接口，ThreadPoolExecutor 是这个接口的实现类。

我们先看看ThreadPoolExecutor 这个类

### ThreadPoolExecutor 提供的构造方法

一共有四个构造方法：

```java
//五个参数的构造函数
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue)

//六个参数的构造函数-1
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory)

//六个参数的构造函数-2
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          RejectedExecutionHandler handler)

//七个参数的构造函数
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)

```

涉及到5~7个参数，我们先看看必须的5个参数是什么意思：

* **int  corePoolSize** 

  该线程池中**核心线程数最大值** 

  > 核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（一等公民），而非核心线程如果长时间的闲置，就会被销毁（二等公民）。

* **int maximumPoolSize** 

  该线程池中**线程总数最大值** 。

  该值等于核心线程数量+非核心线程数量。

* **long keepAliveTime** 

  **非核心线程闲置超时时长**。

  非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut = true，则会作用于核心线程 。

* **TimeUnit unit** 

  keepAliveTime的单位，TimeUnit是一个枚举类型 ，包括以下：

  ```java
  NANOSECONDS ： 1微毫秒 = 1微秒 / 1000
  MICROSECONDS ： 1微秒 = 1毫秒 / 1000
  MILLISECONDS ： 1毫秒 = 1秒 /1000
  SECONDS ： 秒
  MINUTES ： 分
  HOURS ： 小时
  DAYS ： 天
  ```

* **BlockingQueue workQueue** 

  该线程池中的任务队列：维护着等待执行的Runnablere任务对象。

  常用的worksQueue有：

  1. **SynchronousQueue** 
  2. **LinkedBlockingQueue** 
  3. **ArrayBlockingQueue** 
  4. **DelayQueue** 

好了，介绍完5个必须的参数之后，还有两个打酱油的参数，大家知道有这么回事就行，平时基本用不到。

* **ThreadFactory threadFactory** 
* **RejectedExecutionHandler handler** 

### ThreadPoolExecutor的策略

1. 判断**线程池里的核心线程**是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。 
2. 线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。 
3. 判断**线程池里的线程**是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。 

-----此处应该有图



### 饱和策略

### 四种常见的线程池

* **CachedThreadPool**

* **FixedThreadPool**

* **ScheuduledThreadPool**

* **SingleThreadExecutor**

  

## ## 线程池的使用

那说了这么多，你可能有疑惑，我知道new一个ThreadPoolExecutor，大概知道各个参数是干嘛的，可是我new完了，怎么向线程池提交一个要执行的任务啊？

通过ThreadPoolExecutor.execute(Runnable command)方法即可向线程池内添加一个任务



## 参考资料

[线程池，这一篇或许就够了](https://blog.csdn.net/lift_class/article/details/70216690)

