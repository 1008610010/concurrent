# 线程池

## 为什么要使用线程池

1. 创建/销毁线程需要消耗系统资源，线程池可以复用已创建的线程。
2. 控制并发的数量。并发数量过多，可能会导致内存消耗过多，从而造成服务器崩溃。
3. 可以对线程做统一管理。

##  线程池的原理

Java中的线程池顶层接口是Executor接口，ThreadPoolExecutor 是这个接口的实现类。

我们先看看ThreadPoolExecutor 类。

### ThreadPoolExecutor 提供的构造方法

一共有四个构造方法：

```java
//五个参数的构造函数
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue)

//六个参数的构造函数-1
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory)

//六个参数的构造函数-2
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          RejectedExecutionHandler handler)

//七个参数的构造函数
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)

```

涉及到5~7个参数，我们先看看必须的5个参数是什么意思：

* **int  corePoolSize** 

  该线程池中**核心线程数最大值** 

  > 核心线程：线程池中有两类线程，核心线程和非核心线程。核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（铁饭碗），而非核心线程如果长时间的闲置，就会被销毁（临时工）。

* **int maximumPoolSize** 

  该线程池中**线程总数最大值** 。

  > 该值等于核心线程数量+非核心线程数量。

* **long keepAliveTime** 

  **非核心线程闲置超时时长**。

  > 非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置allowCoreThreadTimeOut = true，则会作用于核心线程 。

* **TimeUnit unit** 

  keepAliveTime的单位，TimeUnit是一个枚举类型 ，包括以下：

  ```java
  NANOSECONDS ： 1微毫秒 = 1微秒 / 1000
  MICROSECONDS ： 1微秒 = 1毫秒 / 1000
  MILLISECONDS ： 1毫秒 = 1秒 /1000
  SECONDS ： 秒
  MINUTES ： 分
  HOURS ： 小时
  DAYS ： 天
  ```

* **BlockingQueue workQueue** 

  该线程池中的任务队列：维护着等待执行的Runnablere任务对象。

  常用的worksQueue有：

  1. **SynchronousQueue** 
  2. **LinkedBlockingQueue** 
  3. **ArrayBlockingQueue** 
  4. **DelayQueue** 

好了，介绍完5个必须的参数之后，还有两个打酱油的参数，大家知道有这么回事就行，平时基本用不到。

* **ThreadFactory threadFactory** 

  创建线程的方式 

* **RejectedExecutionHandler handler** 

  拒绝处理策略，线程数量大于最大线程数就会采用拒绝处理策略，四种策略为 ：

  ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 
  ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
  ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
  ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 

### ThreadPoolExecutor的策略

#### 线程池

线程池本身也是一个线程，这个线程就是用于管理布控整个线程池里的各种任务和事务，例如创建线程、销毁线程、任务队列管理、线程队列管理等等。 

故线程池也有自己的状态。ThreadPoolExecutor类中定义了一个volatile变量runState来表示线程池的状态 ，分别为RUNNING、SHURDOWN、STOP、TERMINATED。 

- 线程池创建后处于RUNNING状态。
- 调用shutdown后处于SHUTDOWN状态，线程池不能接受新的任务，会等待缓冲队列的任务完成。
- 调用shutdownNow后处于STOP状态，线程池不能接受新的任务，并尝试终止正在执行的任务。
- 当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态。

#### 线程池主要的任务处理流程

处理任务的核心方法是execute(Runnabel command) ，我们看看ThreadPoolExecutor是如何处理线程任务的：

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    //如果线程数大于等于基本线程数或者线程创建失败，将任务加入队列
    if (poolSize >= corePoolSize || !addIfUnderCorePoolSize(command)) {
        //线程池处于运行状态并且加入队列成功
        if (runState == RUNNING && workQueue.offer(command)) {
            if (runState != RUNNING || poolSize == 0)
                ensureQueuedTaskHandled(command);
        }
        //线程池不处于运行状态或者加入队列失败，则创建线程（创建的是非核心线程）
        else if (!addIfUnderMaximumPoolSize(command))
            //创建线程失败，则采取阻塞处理的方式
            reject(command); 
    }
}
```

总结一下处理流程：

1. 线程总数量<corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量<corePoolSize时）。**注意，这一步需要获得全局锁。**
2. 线程总数量>=corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了线程复用）。 
3. 当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。**注意，这一步需要获得全局锁。**
4. 缓存队列满了， 总线程数又达到了maximumPoolSize，则会采取上面提到的拒绝策略RejectedExecutionHandler 进行处理。

整个过程如图所示：

![](https://raw.githubusercontent.com/chenxiao19920206/RedSpiderArticlePhotos/master/java-base/multi-thread/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%BB%E8%A6%81%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png)

#### ThreadPoolExecutor如何做到线程复用的？

我们知道，一个线程有一个run方法，在线程创建的时候，这个run方法就已经与这个线程绑定了（想想线程的创建方式），当执行完run方法之后，线程自动销毁。**那么，线程池如何做到线程复用呢？**

原来，ThreadPoolExecutor在创建线程时，会将线程封装成**工作线程worker**,并放入**工作线程组**中（区别任务队列），我们看看worker类的部分源码：

```java
private final class Worker implements Runnable {
    private final ReentrantLock runLock = new ReentrantLock();
    private Runnable firstTask;
    volatile long completedTasks;
    Thread thread;//成员变量
    Worker(Runnable firstTask) {
        this.firstTask = firstTask;
    }
    //以下代码省略
    ...
}
```

看到了吗，Thread作为成员变量封装在了worker类中，同时，worker类还有一个成员变量firstTask是runnable类型，这个就是worker被创建时需要执行的第一个任务。

Worker类实现了Runnable接口，那么必然实现了run方法，我们看看他的run方法：

```java
public void run() {
        try {
            Runnable task = firstTask;
            firstTask = null;
            while (task != null || (task = getTask()) != null) {
                runTask(task);
                task = null;
            }
        } finally {
            workerDone(this);   //当任务队列中没有任务时，进行清理工作       
        }
    }
```

首先去执行创建这个works时就有的线程任务，当执行完这个线程任务后，worker的生命周期并没有结束，在while循环中，worker会不断地调用getTask方法从**任务队列**中获取任务然后执行,从而达到**复用线程**的目的。

当然，核心线程池中创建的线程想要拿到任务队列中的任务，先要判断线程池的状态：

* 如果STOP或者TERMINATED，返回NULL，
* 如果是RUNNING或者SHUTDOWN，则从任务队列中拿到任务去执行。 



### 四种常见的线程池

* **CachedThreadPool**

* **FixedThreadPool**

* **ScheuduledThreadPool**

* **SingleThreadExecutor**

  

## 线程池的使用

那说了这么多，你可能有疑惑，我知道new一个ThreadPoolExecutor，大概知道各个参数是干嘛的，可是我new完了，怎么向线程池提交一个要执行的任务啊？

通过ThreadPoolExecutor.execute(Runnable command)方法即可向线程池内添加一个任务



## 参考资料

1. [线程池，这一篇或许就够了](https://blog.csdn.net/lift_class/article/details/70216690)
2. [线程池的使用](https://www.cnblogs.com/zzuli/p/9386463.html)
3. 《并发编程的艺术》
4. [线程池院系详解一](https://www.cnblogs.com/dongguacai/p/6030187.html)

