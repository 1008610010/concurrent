# 第三章 CopyOnWrite容器

## 1.1 什么是CopyOnWrite容器
在说到CopyOnWrite容器之前我们先来谈谈什么是CopyOnWrite机制(以下简称COW)，COW是计算机设计领域中的一种优化策略，也是一种在并发场景下常用的设计思想——写入时复制思想。

那什么是写入时复制思想呢？就是当有多个调用者同时去请求一个资源数据的时候，当有一个调用者出于某些原因需要对当前的源数据进行修改，这个时候系统将会复制一个当前源数据的副本给调用者修改。	

CopyOnWrite容器即写时复制的容器,当我们往一个容器添加元素的时候，不直接往容器中添加，而是将当前容器进行copy，复制出来一个新的容器，然后向新容器中添加我们的元素，最后将原容器的引用指向新容器。这样做的好处在于，我们可以在并发的场景下对容器进行"读操作"不需要"加锁"，从而达到读写分离的目的。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器 ，分别是CopyOnWriteArrayList和CopyOnWriteArraySet 。

## 1.2 CopyOnWriteArrayList
优点：
CopyOnWriteArrayList经常被用于“读多写少”的并发场景，是因为CopyOnWriteArrayList无需任何同步措施，大大增强了读的性能。在Java中List遍历中的时候，
若中途有别的线程对list容器进行修改，那么会抛出ConcurrentModificationException异常。CopyOnWriteArrayList由于其"读写分离"，遍历和修改操作分别作用在不同的list容器，
遍历和修改操作分别都在不同的list容器当中，所以在使用迭代器遍历的时候，所以不会抛出ConcurrentModificationException。
缺点：
1.CopyOnWriteArrayList的缺点也是显而易见的，它每次执行写操作都会将原容器进行拷贝了一份，数据量大的时候，内存会存在较大的压力，可能会引起频繁GC。
2.CopyOnWriteArrayList由于实现的原因，写和读分别作用在新老不同容器上，在写操作执行过程中，读不会阻塞，但读取到的却是老容器的数据。
现在我们来看一下CopyOnWriteArrayList的添加源码,它的逻辑很清晰，就是先把原容器进行copy，然后在新的副本上进行“写操作”，最后再切换引用，
此过程中是加了锁的。

~~~java
public boolean add(E e) {
    /**
    * ReentrantLock加锁，保证线程安全
    */
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
         /**
         * 拷贝原容器，长度为原容器长度加一
          */
         Object[] newElements = Arrays.copyOf(elements, len + 1);
         /**
         * 在新副本上执行添加操作
         */
         newElements[len] = e;
         //将原容器引用指向新副本
         setArray(newElements);
         return true;
         } finally {
         /**
         * 解锁
         */
         lock.unlock();
    }
}
~~~        
我们再来看一下删除操作的源码，删除的逻辑是将要删除元素之外的其他元素拷贝到新的副本中，然后切换引用，再将原容器的引用指向新的副本中，
因为删除也是“写操作”所以也是要加锁的。 
~~~java
public E remove(int index) {
        /**
        * 加锁
        */
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            E oldValue = get(elements, index);
            int numMoved = len - index - 1;
            if (numMoved == 0)
                /**
                * 如果要删除的是列表末端数据，拷贝前len-1个数据到新副本上，再切换引用
                */
                setArray(Arrays.copyOf(elements, len - 1));
            else {
                /**
                 * 否则，将除要删除元素之外的其他元素拷贝到新副本中，并切换引用
                 */
                Object[] newElements = new Object[len - 1];
                System.arraycopy(elements, 0, newElements, 0, index);
                System.arraycopy(elements, index + 1, newElements, index,
                                 numMoved);
                setArray(newElements);
            }
            return oldValue;
        } finally {
            /**
            * 解锁
            */
            lock.unlock();
        }
    }
~~~   
我们再来看看我们CopyOnWriteArrayList效率最高的读操作的源码
~~~java
public E get(int index) {
        return get(getArray(), index);
    }
~~~
~~~java
 private E get(Object[] a, int index) {
        return (E) a[index];
    }
~~~
由上可见“读操作”是没有加锁，直接读取。
**参考资料**

- [线程的几种状态转换](http://www.cnblogs.com/jijijiefang/articles/7222955.html)
- [进程和线程的由来与别](https://blog.csdn.net/whl_program/article/details/70217354)
- [进程、线程、多线程相关总结](https://www.cnblogs.com/fuchongjundream/p/3829508.html)
- [进程的概念/标识/结构/状态](https://blog.csdn.net/derkampf/article/details/60477317)
- [操作系统 - 进程的概念](http://www.cnblogs.com/tianlangshu/p/5224178.html)
- [进程管理笔记一、进程的概念及其产生的背景](https://blog.csdn.net/xd_hebuters/article/details/79590441#一进程产生的背景)
- [上下文切换](http://ifeve.com/context-switch-definition/)
- [进程的概念/标识/结构/状态](https://blog.csdn.net/derkampf/article/details/60477317)
- [线程的生命周期及状态转换详解](https://blog.csdn.net/asdf_1024/article/details/78978437)
- [进程与线程](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319272686365ec7ceaeca33428c914edf8f70cca383000) 
